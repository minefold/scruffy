# uses Fog to talk to EC2
class FogCluster
  def servers
    servers = compute_cloud.servers.select do |s|
      s.state != 'terminated' && tag_filter.all? {|k,v| s.tags[k.to_s] == v.to_s}
    end

    servers.map do |s|
      {
        id: s.id,
        ip: s.public_ip_address,
        type: s.flavor_id,
        started_at: s.created_at,
        state: box_state(s.state),
        tags: s.tags
      }
    end
  end

  def start_new box_type, ami, tags
    private_key_path = File.join(File.dirname(__FILE__), '../../config/aws.pem')
    raise "private_key_path not found" unless File.exist?(private_key_path)

    instance = compute_cloud.servers.bootstrap({
      private_key_path: private_key_path,
      username: 'ubuntu',
      groups: %W{default pinky},
      flavor_id: box_type,
      image_id: ami,
      user_data: cloud_init_script,
      tags: tags,
      block_device_mapping: [
        {'DeviceName' => '/dev/sdb', 'VirtualName' => 'ephemeral0'},
        {'DeviceName' => '/dev/sdc', 'VirtualName' => 'ephemeral1'},
        {'DeviceName' => '/dev/sdd', 'VirtualName' => 'ephemeral2'},
        {'DeviceName' => '/dev/sde', 'VirtualName' => 'ephemeral3'}
      ]
    })

    instance.id
  end
  
  def terminate id
    instance = compute_cloud.servers.get(id)
    instance.destroy
  end

  def compute_cloud
    @compute_cloud ||= Fog::Compute.new({
      :provider                 => 'AWS',
      :aws_secret_access_key    => ENV['AWS_SECRET_KEY'],
      :aws_access_key_id        => ENV['AWS_ACCESS_KEY'],
      :region                   => ENV['AWS_REGION'] || 'us-east-1'
    })
  end

  def box_state ec2_state
    if ec2_state == 'running'
      'up'
    else
      ec2_state
    end
  end

  def tag_filter
    {
      "Name" => "pinky",
      "environment" => Scruffy.env
    }
  end

  def pinky_branch
    'master'
  end

  def log_server
    'logs.partycloud.com'
  end
  
  def configurator_app
    ENV['CONFIGURATOR'] || 'party-cloud-staging'
  end

  def cloud_init_script
    <<-EOS
#!/bin/bash

DOMAIN=minefold.com
HOSTNAME=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
IPV4=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)

# Set the host name
hostname $HOSTNAME
echo $HOSTNAME > /etc/hostname

# Add fqdn to hosts file
cat<<EOF > /etc/hosts
# This file is automatically generated by ec2-hostname script
127.0.0.1 localhost
$IPV4 $HOSTNAME.$DOMAIN $HOSTNAME

# The following lines are desirable for IPv6 capable hosts
::1 ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts
EOF

# restart hostname sensitive services
/etc/init.d/collectd restart
restart rsyslog

sync
echo 3 > /proc/sys/vm/drop_caches

cat<<EOF > /tmp/attributes.json
{
  "pinky": { "branch": "#{pinky_branch}"},
  "relp": { "server": "#{log_server}" },
  "configurator": {
    "app": "#{configurator_app}"
  },
  "run_list":[
    "recipe[rsyslog]",
    "recipe[relp::client]",
    "recipe[configurator]",
    "recipe[pinky::deploy]"
  ]
}
EOF

chef-solo -c /home/ubuntu/chef/ec2/solo.rb -j /tmp/attributes.json
  EOS
  end
end
